def optimizations = {
    "<p>In the latest version, Noc runs in a virtual machine written in C, this feature was implemented in order to earn performances, reduce time execution.</p>

<p>Here is the Noc codebase:</p>

<ul>
  <li>- <a href=\"https://github.com/noc-lang/noc/blob/master/app/Command/CLI.hs\">CLI</a> (written in Haskell)</li>
  <li>- <a href=\"https://github.com/noc-lang/noc/blob/master/src/Language/Noc/Syntax/AST.hs\">Parser</a>/<a href=\"https://github.com/noc-lang/noc/blob/master/src/Language/Noc/Syntax/Lexer.hs\">Lexer</a> (written in Haskell)</li>

  <li>Pre-compilation (written in Haskell)
    <ul>
      <li>- <a href=\"https://github.com/noc-lang/noc/blob/master/src/Language/Noc/Resolution/Imports.hs\">Name Resolution</a></li>
    </ul>
  </li>

  <li>Compiler (written in Haskell)
    <ul>
      <li>- <a href=\"https://github.com/noc-lang/noc/blob/master/src/Language/Noc/Compiler/Bytecode.hs\">Bytecode</a></li>
      <li>- <a href=\"https://github.com/noc-lang/noc/blob/master/src/Language/Noc/Compiler/Serialize.hs\">Serializer</a></li>
    </ul>
  </li>

  <li>- <a href=\"https://github.com/noc-lang/noc/tree/master/src/Language/Noc/VM\">Virtual Machine</a> (written in C)</li>
</ul>

<hr />

<p>Noc generates a bytecode, an intermediate representation much easier to read for the VM.</p>

<p>Bytecode structure: <code>Bytecode {sym = [], constant = [], doc = [], opcodes = []}</code></p>

<p><code>sym</code> => The Noc symbols (primitive functions, noc functions, opcodes (for the quote => it used to push opcode like a symbol in a quote))</p>

<p><code>constant</code> => All Noc values</p>

<p><code>doc</code> => All Noc functions docstrings</p>

<blockquote>
  <p>The fields above are used to earn time in storing essential datas like (constants, call functions) in indexing her thanks to the operand in some opcodes <code>PUSH_CONST index_const_table</code> for example. With this tables, we can avoid the use of hashtables that have usually O(n) time complexity against the indexing that have O(1) in complexity.</p>
</blockquote>

<p><code>opcodes</code> => The Noc program represented with a set of instructions named opcodes</p>

<blockquote>
  <p>The opcodes are linearly represented to avoid trees-recursion and execute each instructions with a basic for loop. A simple loop is much quicker.</p>
</blockquote>

<p>Example:</p>

<pre><code class=\"scala language-scala\">def main = {
    5 5 + print
}
</code></pre>

<p>Bytecode output:</p>

<pre><code class=\"hs language-hs\">Bytecode {
sym = [FuncSym \"main\" 0,OpcodeSym ADD_OP,FuncPrim \"print\" 10], 
constant = [IntConst 5], 
doc = [], 
opcodes = [PUSH_CONST 0,PUSH_CONST 0,ADD_OP,CALL_SYMBOL 2,RETURN]}
</code></pre>

<p>Then, this bytecode is serialized in a file in order to read this bytecode in the VM (written C) in deserializing her.</p>"
    "optimizations"
}